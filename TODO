current:
give each module its own dir, and use package.json to specify the entry point
addition of a module system with adherance to nodules (https://github.com/kriszyp/nodules) package.json changes
downloading of modules automatically
reloading modules automatically
verify the local file, by doing the hash on it and comparing to see if it matches.
add, before() / after() text functions
new class Archive
make playbox functions static to the module
make the module able to be 'new'ed

anyone can do:
limit / offset on query (change the params format to be json)

notes:
check to see if the file is a regular file load the torrent and start it, else start it paused
save songs into the library without metadata and hash them
convert the torrents over to json format and save them as json files... later, load everything from json
make sure the playbox can serve an image as a an album cover
http://chromium.googlecode.com/svn/trunk/samples/audio/specification/specification.html

whenever:
no fumes discos!
configuration panel
log functions (and remove all those horrible console.logs) (and maybe make a git hook to reject commits)
convert and integrate edb to be vertex.js
read up on symbol exports at blog.flameeyes.eu
create the corresponding part hashes while stripping the content as well (how does one do this???)


middle:
integrate head.js
integrate video.js
integrate less.js
integrate unhosted
library cache system
try and grab the album art for the artist
add disk stats into the '?' function
add torrent stats to the progress event
add requiem to allow DRM mp3's to be played in the playbox


after:
abstract the torrent api out to the js a little more, or figure out how to thread it
try and grab the album art for the artist
make a browserplus plugin?


implement the playbox js interface
----------------------------------
implement the object with the following: (depends on the above)
 Object(Playbox)
  -> Event(metadataAdded) - fired when new metadata has been added to the library
  -> Event(archiveUnknown) - fired after archive() or info() call when the metadata can't be found on the dht
  -> Event(archiveLoaded) - fired after archive() or info() when the metadata is available
  -> Event(archiveDownloading) - fired when an archive changes state to downloading
  -> Event(archiveProgress) - fired periodically as an archive is downloading
  -> Event(archiveComplete) - fired when an archive is completely downloaded
  -> Event(archiveRemoved) - fired when an archive is removed from the library
  -> Function(start) - connect it to the network and begin sharing
  -> Function(stop) - disconnect it from the network
  -> Function(archive) - returns an Object with the resulting archive status and a pipe to the archive if it exists
  -> Function(add_archive) - import a traditional file into the library
  -> Function(add_archive_metadata) - import any torrent file or hash
  -> Object(status) - returns the playbox status
  -> Object(stats) - returns the playbox stats
  -> Object(disk_stats) - returns the disk stats
  -> String(library_path) - getter/setter for the library path
  -> String(torrent_path) - getter/setter for the torrent path
  -> Array(dirs) - getter/setter for the array of source directories
  -> Number(scan_speed) - MB/s at which to scan the directories

 Object(Archive)
  -> Event(metadata) - event when metadata is changed or discovered
  -> Event(downloading) - 
  -> Event(progress) - 
  -> Event(complete) - 
  -> Event(paused) - 
  -> String(id) - the hash
  -> String(path) - the real location of the file
  -> String(status) - the current state of the archive
  -> Object(stats) - the stats of the archive

implement a basic application framework
---------------------------------------
allow applications to receive function calls over http
allow applications to receive function calls over plain sockets

implement http interface
------------------------
export the following functions to the http interface:
 [o] disconnect the playbox from the network, but maintain the library functioning
 [-] connect the playbox to the internet, listening on the specified ports
 [q] queries against the library (nothing for the whole library)
 [g] return the archive to http
  -> 100 waiting for first chunk
  -> 200 + contents of the file
  -> 404 file doesn't exist
 [i] request archive info
  -> 100 waiting for the metadata to be downloaded
  -> 200 + js object with object info
  -> 404 metadata cannot be found on the DHT

implement plain socket interface
--------------------------------
I dunno yet :)

determine mp3 duration, id3 data, etc
-------------------------------------
add the C++ library you saw on that dev website
retain the iconv dependency if the above library isn't sufficient


download metadata from dht extension
------------------------------------
it's a plugin for libtorrent-rasterbar, so it should be easy to implement :)


emit events on the js object
----------------------------
implement a comet sort of system which holds the connection, waiting for the event
for the following events:
...


implement a basic client admin interface
----------------------------------------
implement the following functions:
...
write a clientside js application


STUPID SHIT
-----------
fix the stupid submodule bug on my mac for node (and move the submodules to a folder called deps)
fix the deprecated libtorrent stuff (remove deprecated)
make a custom libtorrent library with only the necessary functions
compile the app code into node (removing all of the unused node code) and provide the application with its own context (so node functions can't be accessed)
when autoupdating becomes reality, split up the major node libraries (build with v8, c-ares, and libev)
